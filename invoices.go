package rls

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
)

type InvoiceRequest struct {
	Amount  int64  `json:"amount"`
	Label   string `json:"label"`
	Network string `json:"network"`
}

func NewInvoiceRequest(amount int64, label string, network string) *InvoiceRequest {
	return &InvoiceRequest{
		Amount:  amount,
		Label:   label,
		Network: network,
	}
}

// Invoice contains the response from creating or querying
// a Deposit Invoice.
type Invoice struct {
	ID        string `json:"id,omitempty"`
	Invoice   string `json:"destination"`
	Network   string `json:"network"`
	Timestamp int64  `json:"timestamp,omitempty"`
}

// InvoiceList contains the a page of responses from GetDeposits
type InvoiceList struct {
	Invoices      []Invoice `json:"deposit_intents"`
	NextTimestamp int64     `json:"next_timestamp"`
}

// Count returns the number of Invoices in a InvoiceList
func (dil *InvoiceList) Count() int {
	return len(dil.Invoices)
}

// NewInvoice creates an invoice to enable deposits to RLS
func (rls *RLSClient) NewInvoice(amount int64, label string, network string) (*Invoice, error) {
	invoiceReq := NewInvoiceRequest(amount, label, network)

	body, err := json.Marshal(invoiceReq)
	if err != nil {
		return nil, err
	}
	url := fmt.Sprintf("%s/accounts/%s/deposit_intents", rls.BaseURL(), rls.AccountID())
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer(body))
	if err != nil {
		return nil, err
	}

	var invoice Invoice
	err = rls.sendRequest(req, &invoice)
	if err != nil {
		return nil, err
	}
	return &invoice, nil
}

// GetInvoices queries a list of invoices generated by RLS
func (rls *RLSClient) GetInvoices(limit int64, nextTimestamp int64) (*InvoiceList, error) {
	req, err := http.NewRequest(http.MethodGet, fmt.Sprintf("%s/accounts/%s/deposit_intents", rls.BaseURL(), rls.AccountID()), nil)
	if err != nil {
		return nil, err
	}

	// add query params if they exist
	query := req.URL.Query()
	query.Add("limit", fmt.Sprint(limit))
	if nextTimestamp != 0 {
		query.Add("next_timestamp", fmt.Sprint(nextTimestamp))
	}
	req.URL.RawQuery = query.Encode()

	var invoices InvoiceList
	err = rls.sendRequest(req, &invoices)
	if err != nil {
		return nil, err
	}
	return &invoices, nil
}

// GetNextPageInvoices takes a InvoiceList and returns the next limit Invoices
func (rls *RLSClient) GetNextPageInvoices(limit int64, prevList *InvoiceList) (*InvoiceList, error) {
	return rls.GetInvoices(limit, prevList.NextTimestamp)
}
